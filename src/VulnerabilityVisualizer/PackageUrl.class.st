Class {
	#name : #PackageUrl,
	#superclass : #Object,
	#instVars : [
		'type',
		'namespace',
		'name',
		'version',
		'qualifiers',
		'subpath'
	],
	#category : #'VulnerabilityVisualizer-PURL'
}

{ #category : #'instance creation' }
PackageUrl class >> fromString: aString [

	| split remainder subpath qualifiers scheme type version aName namespace |
	"Split the purl string once from right on '#'
	The left side is the remainder"
	split := $# split: aString.
	split size > 1
		ifTrue: [ 
			remainder := $# join: split allButLast.
			subpath := self parseSubpath: split last ]
		ifFalse: [ 
			remainder := aString.
			subpath := nil ].

	"Split the remainder once from right on '?'
   The left side is the remainder
	The right side is the qualifiers string"
	split := $? split: remainder.
	split size > 1
		ifTrue: [ 
			remainder := $? join: split allButLast.
			qualifiers := self parseQualifiers: split last ]
		ifFalse: [ qualifiers := nil ].

	"Split the remainder once from left on ':'
    The left side lowercased is the scheme
    The right side is the remainder"
	split := $: split: remainder.
	scheme := split first asLowercase.
	remainder := $: join: split allButFirst.

	"Strip the remainder from leading and trailing '/'"
	remainder := remainder trimSlashes.

	"Split this once from left on '/'
	The left side lowercased is the type
	The right side is the remainder"
	split := $/ split: remainder.
	type := split first asLowercase.
	remainder := $/ join: split allButFirst.

	"Split the remainder once from right on '@'
	The left side is the remainder
	Percent-decode the right side. This is the version.
	UTF-8-decode the version if needed in your programming language
	This is the version"
	split := $@ split: remainder.
	split size > 1
		ifTrue: [ 
			remainder := $@ join: split allButLast.
			version := split last urlDecoded ]
		ifFalse: [ version := nil ].

	"Split the remainder once from right on '/'
    The left side is the remainder
    Percent-decode the right side. This is the name
    UTF-8-decode this name if needed in your programming language
    Apply type-specific normalization to the name if needed
    This is the name"
	split := $/ split: remainder.
	split size > 1
		ifTrue: [ 
			remainder := $/ join: split allButLast.
			aName := split last urlDecoded ]
		ifFalse: [ aName := nil ].

	"Split the remainder on '/'
    Discard any empty segment from that split
    Percent-decode each segment
    UTF-8-decode the each segment if needed in your programming language
    Apply type-specific normalization to each segment if needed
    Join segments back with a '/'
    This is the namespace"
	split := (($/ split: remainder) reject: #isEmpty) collect:
		         #urlDecoded.
	namespace := $/ join: split.

	^ self
		  type: type
		  namespace: namespace
		  name: aName
		  version: version
		  qualifiers: qualifiers
		  subpath: subpath
]

{ #category : #accessing }
PackageUrl class >> neoJsonMapping: mapper [

	mapper for: self customDo: [ :mapping | 
		mapping
			decoder: [ :string | self fromString: string ];
			encoder: [ :mimeType | self halt ] ]
]

{ #category : #private }
PackageUrl class >> parseQualifiers: aString [

	| qualifiers pairs |
	qualifiers := Dictionary new.
	"Split the qualifiers on '&'. Each part is a key=value pair"
	pairs := $& split: aString.
	pairs do: [ :pair | 
		| split key value |
		"For each pair, split the key=value once from left on '=':"
		split := $= split: pair.
		"The key is the lowercase left side"
		key := split first asLowercase.
		"The value is the percent-decoded right side"
		value := split second urlDecoded.
		"UTF-8-decode the value if needed in your programming language"
		"Discard any key/value pairs where the value is empty"
		(key isEmpty or: [ value isEmpty ]) ifFalse: [ 
			qualifiers at: key put: (key = 'checksums'
					 ifTrue: [ "If the key is checksums, split the value on ',' to create a list of checksums" 
						 $, split: value ]
					 ifFalse: [ value ]) ] ].
	"This list of key/value is the qualifiers object"
	^ qualifiers
]

{ #category : #private }
PackageUrl class >> parseSubpath: aString [

	| subpath |
	"Strip the right side from leading and trailing '/'"
	subpath := aString trimSlashes.
	"Split this on '/'"
	subpath := $/ split: subpath.
	"Discard any empty string segment from that split
	Discard any '.' or '..' segment from that split"
	subpath := subpath reject: [ :each | 
		           each isEmpty or: [ each = '.' or: each = '..' ] ].
	"Percent-decode each segment"
	subpath := subpath do: #urlDecoded.
	"UTF-8-decode each segment if needed in your programming language"
	"Join segments back with a '/'
	This is the subpath"
	^ $/ join: subpath
]

{ #category : #'instance creation' }
PackageUrl class >> type: aType namespace: aNamespace name: aName version: aVersion qualifiers: aDictionary subpath: aSubpath [

	^ self new
		  setType: aType
		  namespace: aNamespace
		  name: aName
		  version: aVersion
		  qualifiers: aDictionary
		  subpath: aSubpath;
		  yourself
]

{ #category : #accessing }
PackageUrl >> canonical [

	^ String streamContents: [ :stream | self printCanonicalOn: stream ]
]

{ #category : #accessing }
PackageUrl >> name [
	^ name
]

{ #category : #accessing }
PackageUrl >> namespace [
	^ namespace
]

{ #category : #printing }
PackageUrl >> printCanonicalOn: aStream [

	aStream
		nextPutAll: 'pkg:';
		nextPutAll: type;
		nextPut: $/;
		nextPutAll: namespace;
		nextPut: $/;
		nextPutAll: name.
	version ifNotNil: [ :value | 
		aStream
			nextPut: $@;
			nextPutAll: value ].
	qualifiers ifNotNil: [ :dic | 
		aStream nextPut: $?.
		dic keys sorted
			do: [ :key | 
				aStream
					nextPutAll: key;
					nextPut: $=;
					nextPutAll: (dic at: key) ]
			separatedBy: [ aStream nextPut: $& ] ]
]

{ #category : #accessing }
PackageUrl >> qualifiers [
	^ qualifiers
]

{ #category : #private }
PackageUrl >> sanitize [

	qualifiers := qualifiers ifNotNil: [ :orig | 
		              | new |
		              new := Dictionary new.
		              orig keysAndValuesDo: [ :key :value | 
			              new at: key asLowercase put: value ].
		              new ].

	type = 'bitbucket' ifTrue: [ ^ self sanitizeBitbucket ].
	type = 'github' ifTrue: [ ^ self sanitizeGithub ]
]

{ #category : #private }
PackageUrl >> sanitizeBitbucket [

	namespace := namespace asLowercase.
	name := name asLowercase
]

{ #category : #private }
PackageUrl >> sanitizeGithub [

	namespace := namespace asLowercase.
	name := name asLowercase
]

{ #category : #initialization }
PackageUrl >> setType: aType namespace: aNamespace name: aName version: aVersion qualifiers: aDictionary subpath: aSubpath [

	type := aType.
	namespace := aNamespace.
	name := aName.
	version := aVersion.
	qualifiers := aDictionary.
	subpath := aSubpath.
	self sanitize
]

{ #category : #accessing }
PackageUrl >> subpath [
	^ subpath
]

{ #category : #accessing }
PackageUrl >> type [
	^ type
]

{ #category : #accessing }
PackageUrl >> version [
	^ version
]
