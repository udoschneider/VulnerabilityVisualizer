Class {
	#name : #FugueIcons,
	#superclass : #Object,
	#instVars : [
		'name',
		'url',
		'icons',
		'reportNotFound'
	],
	#classVars : [
		'Current'
	],
	#category : #VulnerabilityVisualizer
}

{ #category : #'instance creation' }
FugueIcons class >> current [ 
	"WARNING: Direct access to this method is ill-adviced, use Smalltalk ui icons instead."
	^ Current ifNil: [ Current := self loadDefault ]
]

{ #category : #'instance creation' }
FugueIcons class >> current: aPack [
	aPack hasIcons ifFalse: [ aPack loadIconsFromUrl ].
	Current := aPack.
	SystemAnnouncer uniqueInstance announce: IconSetChanged
]

{ #category : #accessing }
FugueIcons class >> defaultUrl [

	^ 'https://p.yusukekamiyamane.com/icons/downloads/fugue-icons-3.5.6.zip'
		  asUrl
]

{ #category : #accessing }
FugueIcons class >> destinationPath [
	^ 'icon-packs' asFileReference
]

{ #category : #private }
FugueIcons class >> loadDefault [

	^ self new
		  name: 'fugue';
		  loadIconsFromUrl;
		  yourself
]

{ #category : #'instance creation' }
FugueIcons class >> named: aString [ 
	^ self new name: aString
]

{ #category : #'instance creation' }
FugueIcons class >> reset [
	<script>
	
	Current := nil
]

{ #category : #settings }
FugueIcons class >> wrapIconPack: aPack [
	^ aPack name
]

{ #category : #comparing }
FugueIcons >> = anotherObject [

	^ self species = anotherObject species
		and: [ self name = anotherObject name ]
]

{ #category : #accessing }
FugueIcons >> allIconNames [
	"Returns the names of all the available icons"
	^ self icons keys
]

{ #category : #accessing }
FugueIcons >> beCurrent [
	self class current: self
]

{ #category : #accessing }
FugueIcons >> beNotReportNotFound [
	reportNotFound := false
]

{ #category : #accessing }
FugueIcons >> beReportNotFound [
	reportNotFound := true
]

{ #category : #accessing }
FugueIcons >> blankIcon [
	^ self blankIconOfWidth: 16
]

{ #category : #utilities }
FugueIcons >> blankIconOfWidth: aNumber [ 
	^ self icons
		at: ('blank-' , aNumber asString) asSymbol
		ifAbsentPut: [Form extent: aNumber @ 1 depth: 8]
]

{ #category : #private }
FugueIcons >> defaultUrl [

	^ self class defaultUrl 
]

{ #category : #'reflective operations' }
FugueIcons >> doesNotUnderstand: aMessage [
	"WARNING: This is "
	aMessage selector isUnary 
		ifTrue: [ ^ self iconNamed: aMessage selector ].	
	^ super doesNotUnderstand: aMessage
]

{ #category : #loading }
FugueIcons >> downloadFromUrl [
	| zipArchive |
	self class destinationPath ensureCreateDirectory. 	
	zipArchive := self class destinationPath / (self name, '.zip').
	zipArchive exists 
		ifFalse: [ 
			ZnClient new
				url: self url;
				downloadTo: zipArchive ].

	^ zipArchive
]

{ #category : #utilities }
FugueIcons >> form16x16FromContents: aByteArray [ 
	^ Form
	extent: 16@16
	depth: 32
	fromArray: aByteArray 
	offset: 0@0
]

{ #category : #testing }
FugueIcons >> hasIcons [
	^ self icons notEmpty
]

{ #category : #comparing }
FugueIcons >> hash [ 
	
	^ self name hash
]

{ #category : #accessing }
FugueIcons >> iconNamed: aSymbol [
	^ (self 
		iconNamed: aSymbol 
		ifNone: [ 
			self isReportingNotFound 
				ifTrue: [ 
					self crTrace: (aSymbol, ' icon not found!').
					self notFoundIcon ]
				ifFalse: [ self blankIcon ]]) scaledByDisplayScaleFactor
]

{ #category : #accessing }
FugueIcons >> iconNamed: aSymbol ifNone: aBlock [

	self icons at: aSymbol asSymbol ifPresent: [ :icon | ^ icon ].
	"Trying the old way"
	
	((aSymbol endsWith: 'Icon') or: [ (aSymbol endsWith: 'Form') ]) ifTrue: [ 
		self icons 
			at: (aSymbol allButLast: 4) asSymbol 
			ifPresent: [ :icon | ^ icon ] 
	].

	^ aBlock value
]

{ #category : #accessing }
FugueIcons >> icons [ 
	^ icons ifNil: [ icons := Dictionary new: 0 ]
]

{ #category : #testing }
FugueIcons >> isReportingNotFound [
	^ reportNotFound ifNil: [ reportNotFound := false ]
]

{ #category : #loading }
FugueIcons >> loadIconsFromUrl [

	| newIcons zipArchive |
	newIcons := IdentityDictionary new.
	zipArchive := self downloadFromUrl.
	((FileSystem zip: zipArchive) open workingDirectory / 'icons' 
		 allChildrenMatching: '*.png')
		reject: [ :each | each base beginsWith: '.' ]
		thenDo: [ :each | 
			[ newIcons at: each base asSymbol put: (self readPNGFrom: each) ]
				on: Error
				do: [ :e | self crTrace: each fullName , ' not a PNG, skipping.' ] ].
	icons := newIcons
]

{ #category : #accessing }
FugueIcons >> name [
	^ name
]

{ #category : #accessing }
FugueIcons >> name: aName [
	name := aName
]

{ #category : #accessing }
FugueIcons >> notFoundIcon [
	^ self icons
		at: #notFoundIcon
		ifAbsentPut: [ Color red iconOrThumbnailOfSize: 16 ]
]

{ #category : #printing }
FugueIcons >> printOn: stream [ 
	super printOn: stream.
	stream << $( << self name << $)
]

{ #category : #private }
FugueIcons >> readPNGFrom: aReference [
	^ aReference binaryReadStreamDo: [ :stream | 
		PNGReadWriter formFromStream: stream ]
]

{ #category : #accessing }
FugueIcons >> url [
	^ url ifNil: [ url := self defaultUrl ]
]

{ #category : #accessing }
FugueIcons >> url: aStringOrUrl [
	url := aStringOrUrl ifNotNil: [ aStringOrUrl asUrl ]
]
